#include "test.h"

#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>


#include <cmocka.h>


#include "parser.h"
#include "pretty_print.h"
#include "scanner.h"
#include "token.h"
#include "error.h"

enum AstType_t {AST_EXPR, AST_DECL, AST_STMT};

static _Bool test_ast_compare(
  const char* source,
  const char* expected,
  enum AstType_t ast_type
) {
  Scanner* scanner = Scanner_init(source);
  Parser* parser = Parser_init(scanner);
  _Bool success = true;

  char ast_str[256] = "";
  switch(ast_type) {
    case AST_EXPR:
        pretty_print_expr(Parser_expression(parser), ast_str, sizeof(ast_str));
        break;
    case AST_DECL:
        pretty_print_decl(Parser_translation_unit(parser), ast_str, sizeof(ast_str));
        break;
    case AST_STMT:
        pretty_print_stmt(Parser_compound_statement(parser), ast_str, sizeof(ast_str));
        break; 
  }

  if(strlen(ast_str) != strlen(expected) || strcmp(ast_str, expected) != 0) {
    printf("FAIL. Expected '%s', got '%s' (source: '%s')\n", expected, ast_str, source);
    success = false;

  } else if (Parser_peek_next_token(parser)->type != END_OF_FILE) {
    printf("FAIL. Expected 'END_OF_FILE', got '%s'\n", 
      Token_str(Parser_peek_next_token(parser)->type)
    );
    success = false;

  }

  Parser_destroy(parser);
  Scanner_destroy(scanner);
  return success;
}

/*
 * Check if the string representation for an expression source input matches
 * the expected AST. (Assuming no errors occur.)
 */
_Bool test_ast_compare_expr(const char* source, const char* expected) {
  return test_ast_compare(source, expected, AST_EXPR);
}

/*
 * Check if the string representation for an declaration source input matches
 * the expected AST. (Assuming no errors occur.)
 */
_Bool test_ast_compare_decl(const char* source, const char* expected) {
  return test_ast_compare(source, expected, AST_DECL);
}

/*
 * Check if the string representation for an statement source input matches
 * the expected AST. (Assuming no errors occur.)
 */
_Bool test_ast_compare_stmt(const char* source, const char* expected) {
  return test_ast_compare(source, expected, AST_STMT);
}

/*
 * For each <source input, expected AST> pair in the test fixture, verify
 * the expression AST generated by the parser.
 */
void assert_expected_ast_expr(AstTestFixture* fixture) {
  for (; fixture->source; fixture++) {
    assert_true(test_ast_compare_expr(fixture->source, fixture->expected));
  }
}

/*
 * For each <source input, expected AST> pair in the test fixture, verify
 * the declaration AST generated by the parser.
 */
void assert_expected_ast_decl(AstTestFixture* fixture) {
  for (; fixture->source; fixture++) {
    assert_true(test_ast_compare_decl(fixture->source, fixture->expected));
  }
}

/*
 * For each <source input, expected AST> pair in the test fixture, verify
 * the statement AST generated by the parser.
 */
void assert_expected_ast_stmt(AstTestFixture* fixture) {
  for (; fixture->source; fixture++) {
    assert_true(test_ast_compare_stmt(fixture->source, fixture->expected));
  }
}

/*
 * Mock Error_report_error function
 */
void Error_report_error(ErrorType error_type, int line_number,
                        const char* error_string) {
  function_called();
  check_expected(error_type);
  check_expected(line_number);
  check_expected(error_string);
}

/*
 * Helper function for declaring expected errors.
 */
void expect_report_error(ErrorType error_type, int expect_line, char* expect_err_str) {
  expect_function_call(Error_report_error);
  expect_value(Error_report_error, error_type, error_type);
  expect_value(Error_report_error, line_number, expect_line);
  expect_string(Error_report_error, error_string, expect_err_str);
}

/* 
 * Mock symbol table functions
 */
SymbolTable* __wrap_symbol_table_create(SymbolTable* parent){
    check_expected(parent);
    return (SymbolTable*)mock();
}
Symbol* __wrap_symbol_table_put(SymbolTable* tab, char* name, CType* type) {
    if(!strcmp(name, "ignoreme")) return NULL;
    check_expected(tab);
    check_expected(name);
    return (Symbol*)mock();
}
Symbol* __wrap_symbol_table_get(SymbolTable* tab, char* name, bool search_parent) {
    if(!strcmp(name, "ignoreme")) return NULL;
    check_expected(tab);
    check_expected(name);
    check_expected(search_parent);
    return (Symbol*)mock();
}

/* 
 * Helper functions for checking mock function parameters and setting return values
 */
void expect_symbol_create(SymbolTable* parent, SymbolTable* ret) {
    expect_value(__wrap_symbol_table_create, parent, parent);
    will_return(__wrap_symbol_table_create, ret);
}
void expect_symbol_put(SymbolTable* tab, char* name, Symbol* ret) {
    expect_value(__wrap_symbol_table_put, tab, tab);
    expect_string(__wrap_symbol_table_put, name, name);
    will_return(__wrap_symbol_table_put, ret);
}
void expect_symbol_get(SymbolTable* tab, char* name, bool search_parent, Symbol* ret) {
    expect_value(__wrap_symbol_table_get, tab, tab);
    expect_string(__wrap_symbol_table_get, name, name);
    expect_value(__wrap_symbol_table_get, search_parent, search_parent);
    will_return(__wrap_symbol_table_get, ret);
}