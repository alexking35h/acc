import re, os, datetime

FILE_TEMPLATE = """\
/* Recursive Descent Parser implementation ({category})
 * 
 * The recursive descent parser is implemented as a set of mutually recursive functions
 * for each rule in the grammar. This file provides functions for rules in the '{category}'
 * set.
 * 
 * Generated by {script_name} on {date}.
 */

#include <stddef.h>

#include "ast.h"
#include "parser.h"

"""

FUNCTION_TEMPLATE = """\
AstNode * Parser_{rule_name}(Parser * parser) {{    // @TODO
{comment}

  return NULL;
}}
"""

RULE_SETS = {
    "expression": [
        "primary_expression",
        "constant",
        "enumeration_constant",
        "string",
        "generic_selection",
        "generic_assoc_list",
        "generic_association",
        "postfix_expression",
        "argument_expression_list",
        "unary_expression",
        "unary_operator",
        "cast_expression",
        "multiplicative_expression",
        "additive_expression",
        "shift_expression",
        "relational_expression",
        "equality_expression",
        "and_expression",
        "exclusive_or_expression",
        "inclusive_or_expression",
        "logical_and_expression",
        "logical_or_expression",
        "conditional_expression",
        "assignment_expression",
        "assignment_operator",
        "expression",
        "constant_expression",
    ],
    "declaration": [
        "declaration",
        "declaration_specifiers",
        "init_declarator_list",
        "init_declarator",
        "storage_class_specifier",
        "type_specifier",
        "struct_or_union_specifier",
        "struct_or_union",
        "struct_declaration_list",
        "struct_declaration",
        "specifier_qualifier_list",
        "struct_declarator_list",
        "struct_declarator",
        "enum_specifier",
        "enumerator_list",
        "enumerator",
        "atomic_type_specifier",
        "type_qualifier",
        "function_specifier",
        "alignment_specifier",
        "declarator",
        "direct_declarator",
        "pointer",
        "type_qualifier_list",
        "parameter_type_list",
        "parameter_list",
        "parameter_declaration",
        "identifier_list",
        "type_name",
        "abstract_declarator",
        "direct_abstract_declarator",
        "initializer",
        "initializer_list",
        "designation",
        "designator_list",
        "designator",
        "static_assert_declaration",
        "translation_unit",
        "external_declaration",
        "function_definition",
        "declaration_list",
    ],
    "statement": [
        "statement",
        "labeled_statement",
        "compound_statement",
        "block_item_list",
        "block_item",
        "expression_statement",
        "selection_statement",
        "iteration_statement",
        "jump_statement",
    ]
}

parser_code = {set_name:"" for set_name in RULE_SETS}

def generate_parser_files(grammar_file):
    grammar = open(grammar_file, 'r').read()   
    grammar = grammar.replace("\n", " ").replace("\t", "")
    
    for rule, body in re.findall("(\w+) *: *([^;]+)", grammar):
        branches = body.split(" | ")
        function_comment = "  /*\n   * " + "\n   * ".join(branches) + "\n   */"

        code = FUNCTION_TEMPLATE.format(rule_name=rule, comment=function_comment)

        for set_name, set_rules in RULE_SETS.items():
            if rule in set_rules:
                parser_code[set_name] = parser_code[set_name] + code
                break
        else:
            print(f"unknown rule: {rule}")

    assert all(not os.path.exists(f"parser_{f}.c") for f in parser_code)
    
    for name, code in parser_code.items():
        with open(f"parser_{name}.c", "w") as fil:
            file_header = FILE_TEMPLATE.format(
                category=name,
                script_name=__file__,
                date=datetime.datetime.now().strftime("%Y-%m-%d")
            )
            fil.write(file_header + code)

generate_parser_files("grammar.yacc")
