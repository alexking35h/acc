/* Recursive Descent Parser implementation (expression)
 *
 * The recursive descent parser is implemented as a set of mutually recursive
 * functions for each rule in the grammar. This file provides functions for
 * rules in the 'expression' set.
 *
 * Generated by generate_recursive_parser.py on 2020-03-24.
 */

#include <stddef.h>

#include "ast.h"
#include "parser.h"
#include "token.h"

#define match(...) Parser_match_token(parser, (TokenType[]){__VA_ARGS__, NAT})
#define consume(t) Parser_consume_token(parser, t)
#define peek() Parser_peek_token(parser)

// Horrible hack, for now, to get rid of the compiler warnings
//#define static

static AstNode* primary_expression(Parser*);
static AstNode* postfix_expression(Parser*);
static AstNode* argument_expression_list(Parser*);
static AstNode* unary_expression(Parser*);
static AstNode* cast_expression(Parser*);
static AstNode* multiplicative_expression(Parser*);
static AstNode* additive_expression(Parser*);
static AstNode* shift_expression(Parser*);
static AstNode* relational_expression(Parser*);
static AstNode* equality_expression(Parser*);
static AstNode* and_expression(Parser*);
static AstNode* exclusive_or_expression(Parser*);
static AstNode* inclusive_or_expression(Parser*);
static AstNode* logical_and_expression(Parser*);
static AstNode* logical_or_expression(Parser*);
static AstNode* conditional_expression(Parser*);
static AstNode* assignment_expression(Parser*);

static AstNode* desugar_assign(Parser* parser, AstNode* expr, TokenType op,
                               AstNode* operand) {
  /* A bunch of the C syntax is treated as syntactic sugar, to make the AST more
   * homogeneous and (hopefully) make it easier to implement later parts of the
   * compiler. This includes ++ and -- postfix operators, and assignment
   * operators (+=, -=, /=, etc.)
   */
  char* op_tok_str;
  switch (op) {
    case PLUS:
      op_tok_str = "+";
      break;
    case MINUS:
      op_tok_str = "-";
      break;
    case STAR:
      op_tok_str = "*";
      break;
    case SLASH:
      op_tok_str = "/";
      break;
    case PERCENT:
      op_tok_str = "%";
      break;
    case LEFT_OP:
      op_tok_str = "<<";
      break;
    case RIGHT_OP:
      op_tok_str = ">>";
      break;
    case AMPERSAND:
      op_tok_str = "&";
      break;
    case CARET:
      op_tok_str = "^";
      break;
    case BAR:
      op_tok_str = "|";
      break;
    default:
      op_tok_str = "?";
      break;
  }
  Token* op_token = Parser_create_fake_token(parser, op, op_tok_str);
  AstNode* op_expr = AST_BINARY(.left = expr, .op = op_token, .right = operand);

  return AST_ASSIGN(.left = expr, .right = op_expr);
}

static AstNode* primary_expression(Parser* parser) {  // @DONE
  /*
   * IDENTIFIER
   * constant
   * string
   * '(' expression ')'
   * generic_selection  @TODO
   */
  Token* next;

  if ((next = match(IDENTIFIER)))
    return AST_PRIMARY(.type = PRIMARY_IDENTIFIER, .identifier = next);

  if ((next = match(CONSTANT)))
    return AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = next);

  if ((next = match(STRING_LITERAL)))
    return AST_PRIMARY(.type = PRIMARY_STRING_LITERAL, .string_literal = next);

  if (match(LEFT_PAREN)) {
    AstNode* expr = Parser_expression(parser);
    consume(RIGHT_PAREN);
    return expr;
  }

  return NULL;
}
static AstNode* postfix_expression(Parser* parser) {
  /*
   * primary_expression
   * postfix_expression '[' expression ']'
   * postfix_expression '(' ')'                           @TODO
   * postfix_expression '(' argument_expression_list ')'  @TODO
   * postfix_expression '.' IDENTIFIER
   * postfix_expression PTR_OP IDENTIFIER
   * postfix_expression INC_OP
   * postfix_expression DEC_OP
   * '(' type_name ')' '{' initializer_list '}'           @TODO
   * '(' type_name ')' '{' initializer_list ',' '}'       @TODO
   */
  AstNode* expr = primary_expression(parser);
  Token* token;

  while (true) {
    if (match(LEFT_SQUARE)) {
      AstNode* index = Parser_expression(parser);
      consume(RIGHT_SQUARE);
      expr = AST_POSTFIX(.type = POSTFIX_ARRAY_INDEX, .left = expr,
                         .index_expression = index);
    } else if ((token = match(INC_OP))) {
      // INC_OP is desugaured into: a++ -> a=a+1
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      AstNode* constant_node =
          AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

      return desugar_assign(parser, expr, PLUS, constant_node);
    } else if ((token = match(DEC_OP))) {
      // DEC_OP is desugaured into: a++ -> a=a-1
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      AstNode* constant_node =
          AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

      return desugar_assign(parser, expr, MINUS, constant_node);
    } else
      break;
  }
  return expr;
}
static AstNode* argument_expression_list(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * argument_expression_list ',' assignment_expression
   */

  return NULL;
}
static AstNode* unary_expression(Parser* parser) {  // @DONE
  /*
   * postfix_expression
   * INC_OP unary_expression
   * DEC_OP unary_expression
   * unary_operator cast_expression
   * SIZEOF unary_expression
   * SIZEOF '(' type_name ')'   @TODO
   * ALIGNOF '(' type_name ')'  @TODO
   */
  Token* token;

  if ((token = match(AMPERSAND, STAR, PLUS, MINUS, TILDE, BANG, SIZEOF, INC_OP,
                     DEC_OP)))
    return AST_UNARY(.op = token, .right = unary_expression(parser));

  return postfix_expression(parser);
}

static AstNode* cast_expression(Parser* parser) {  // @TODO
  /*
   * unary_expression
   * '(' type_name ')' cast_expression
   */
  return unary_expression(parser);
}
static AstNode* multiplicative_expression(Parser* parser) {  // @DONE
  /*
   * cast_expression
   * multiplicative_expression '*' cast_expression
   * multiplicative_expression '/' cast_expression
   * multiplicative_expression '%' cast_expression
   */
  AstNode* expr = cast_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(STAR, SLASH, PERCENT))) break;

    AstNode* right = cast_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* additive_expression(Parser* parser) {  // @DONE
  /*
   * multiplicative_expression
   * additive_expression '+' multiplicative_expression
   * additive_expression '-' multiplicative_expression
   */
  AstNode* expr = multiplicative_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(PLUS, MINUS))) break;

    AstNode* right = multiplicative_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* shift_expression(Parser* parser) {  // @DONE
  /*
   * additive_expression
   * shift_expression LEFT_OP additive_expression
   * shift_expression RIGHT_OP additive_expression
   */
  AstNode* expr = additive_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(LEFT_OP, RIGHT_OP))) break;

    AstNode* right = additive_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* relational_expression(Parser* parser) {  // @DONE
  /*
   * shift_expression
   * relational_expression '<' shift_expression
   * relational_expression '>' shift_expression
   * relational_expression LE_OP shift_expression
   * relational_expression GE_OP shift_expression
   */
  AstNode* expr = shift_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(LESS_THAN, GREATER_THAN, LE_OP, GE_OP))) break;

    AstNode* right = shift_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* equality_expression(Parser* parser) {  // @DONE
  /*
   * relational_expression
   * equality_expression EQ_OP relational_expression
   * equality_expression NE_OP relational_expression
   */
  AstNode* expr = relational_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(EQ_OP, NE_OP))) break;

    AstNode* right = relational_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;

  return relational_expression(parser);
}
static AstNode* and_expression(Parser* parser) {  // @DONE
  /*
   * equality_expression
   * and_expression '&' equality_expression
   */
  AstNode* expr = equality_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(AMPERSAND))) break;

    AstNode* right = equality_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* exclusive_or_expression(Parser* parser) {  // @DONE
  /*
   * and_expression
   * exclusive_or_expression '^' and_expression
   */
  AstNode* expr = and_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(CARET))) break;

    AstNode* right = and_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* inclusive_or_expression(Parser* parser) {  // @DONE
  /*
   * exclusive_or_expression
   * inclusive_or_expression '|' exclusive_or_expression
   */
  AstNode* expr = exclusive_or_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(BAR))) break;

    AstNode* right = exclusive_or_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* logical_and_expression(Parser* parser) {  // @DONE
  /*
   * inclusive_or_expression
   * logical_and_expression AND_OP inclusive_or_expression
   */
  AstNode* expr = inclusive_or_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(AND_OP))) break;

    AstNode* right = inclusive_or_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* logical_or_expression(Parser* parser) {  // @DONE
  /*
   * logical_and_expression
   * logical_or_expression OR_OP logical_and_expression
   */
  AstNode* expr = logical_and_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator= match(OR_OP))) break;

    AstNode* right = logical_and_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}

static AstNode* conditional_expression(Parser* parser) {  // @DONE
  /*
   * logical_or_expression
   * logical_or_expression '?' expression ':' conditional_expression
   */
  AstNode* expr = logical_or_expression(parser);
  if (!match(QUESTION)) return expr;

  AstNode* expr_true = Parser_expression(parser);
  consume(COLON);
  AstNode* expr_false = conditional_expression(parser);

  return AST_TERTIARY(.condition_expr = expr, .expr_true = expr_true,
                      .expr_false = expr_false);
}

static AstNode* assignment_expression(Parser* parser) {  // @DONE
  /*
   * conditional_expression
   * unary_expression assignment_operator assignment_expression
   */

  // The FIRST sets for the grammar rules 'conditional_expression' and
  // 'unary_expression' are not disjoint. To sidestep this,
  // 'assignment_expression is parsed as: : conditional_expression |
  // conditional_expression assignment_operator conditional_expression.
  //
  // Later we'll come back to make sure the lvalue is valid.
  AstNode* expr = conditional_expression(parser);
  Token* operator;

  while (true) {
    operator= match(EQUAL);
    if (operator!= NULL) {
      AstNode* right = assignment_expression(parser);
      expr = AST_ASSIGN(.left = expr, .right = right);
      continue;
    }

    operator=
        match(MUL_ASSIGN, DIV_ASSIGN, MOD_ASSIGN, ADD_ASSIGN, SUB_ASSIGN,
              LEFT_ASSIGN, RIGHT_ASSIGN, AND_ASSIGN, XOR_ASSIGN, OR_ASSIGN);

    if (operator!= NULL) {
      TokenType tok_type;
      switch (operator->type) {
        case MUL_ASSIGN:
          tok_type = STAR;
          break;
        case DIV_ASSIGN:
          tok_type = SLASH;
          break;
        case MOD_ASSIGN:
          tok_type = PERCENT;
          break;
        case ADD_ASSIGN:
          tok_type = PLUS;
          break;
        case SUB_ASSIGN:
          tok_type = MINUS;
          break;
        case LEFT_ASSIGN:
          tok_type = LEFT_OP;
          break;
        case RIGHT_ASSIGN:
          tok_type = RIGHT_OP;
          break;
        case AND_ASSIGN:
          tok_type = AMPERSAND;
          break;
        case XOR_ASSIGN:
          tok_type = CARET;
          break;
        case OR_ASSIGN:
          tok_type = BAR;
          break;
        default:
          break;
      }
      AstNode* right = assignment_expression(parser);
      expr = desugar_assign(parser, expr, tok_type, right);
    } else {
      break;
    }
  }
  return expr;
}

AstNode* Parser_expression(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * expression ',' assignment_expression
   */
  AstNode* expr = assignment_expression(parser);

  if (match(COMMA)) {
    return AST_EXPR(.expr = expr, .next = Parser_expression(parser));
  } else {
    return expr;
  }
}
