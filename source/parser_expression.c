/* Recursive Descent Parser implementation (expression)
 *
 * The recursive descent parser is implemented as a set of mutually recursive
 * functions for each rule in the grammar. This file provides functions for
 * rules in the 'expression' set.
 *
 * Generated by generate_recursive_parser.py on 2020-03-24.
 */

#include <stddef.h>

#include "ast.h"
#include "parser.h"
#include "token.h"

#define match(...)  Parser_match_token(parser, (TokenType[]){__VA_ARGS__, NAT})
#define consume(t)  Parser_consume_token(parser, t)
#define peek()      Parser_peek_token(parser)

// Horrible hack, for now, to get rid of the compiler warnings
#define static

static AstNode* primary_expression(Parser*);
static AstNode* constant(Parser*);
static AstNode* enumeration_constant(Parser*);
static AstNode* string(Parser*);
static AstNode* generic_selection(Parser*);
static AstNode* generic_assoc_list(Parser*);
static AstNode* generic_association(Parser*);
static AstNode* postfix_expression(Parser*);
static AstNode* argument_expression_list(Parser*);
static AstNode* unary_expression(Parser*);
static AstNode* cast_expression(Parser*);
static AstNode* multiplicative_expression(Parser*);
static AstNode* additive_expression(Parser*);
static AstNode* shift_expression(Parser*);
static AstNode* relational_expression(Parser*);
static AstNode* equality_expression(Parser*);
static AstNode* and_expression(Parser*);
static AstNode* exclusive_or_expression(Parser*);
static AstNode* inclusive_or_expression(Parser*);
static AstNode* logical_and_expression(Parser*);
static AstNode* logical_or_expression(Parser*);
static AstNode* conditional_expression(Parser*);
static AstNode* assignment_expression(Parser*);
static AstNode* assignment_operator(Parser*);
static AstNode* constant_expression(Parser*);

static AstNode* desugar_assign(Parser* parser, AstNode* expr, TokenType op,
                               AstNode* operand) {
  /* A bunch of the C syntax is treated as syntactic sugar, to make the AST more
   * homogeneous and (hopefully) make it easier to implement later parts of the
   * compiler). This includes ++ and -- pre/postfix operators, and assignment
   * operators (+=, -=, /=, etc.)
   */
  char* op_token_str;
  switch (op) {
    case PLUS:
      op_token_str = "+";
      break;
    case MINUS:
      op_token_str = "-";
      break;
    default:
      op_token_str = "?";
      break;
  }
  Token* op_token = Parser_create_fake_token(parser, op, op_token_str);
  AstNode* op_expr = AST_BINARY(.left = expr, .op = op_token, .right = operand);

  Token* equal_token = Parser_create_fake_token(parser, EQUAL, "=");
  return AST_BINARY(.left = expr, .op = equal_token, .right = op_expr);
}

static AstNode* primary_expression(Parser* parser) {  // @DONE
  /*
   * IDENTIFIER
   * constant
   * string
   * '(' expression ')'
   * generic_selection  @TODO
   */
  Token* next;

  if ((next = match(IDENTIFIER)))
    return AST_PRIMARY(.type = PRIMARY_IDENTIFIER, .identifier = next);

  if ((next = match(CONSTANT)))
    return AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = next);

  if ((next = match(STRING_LITERAL)))
    return AST_PRIMARY(.type = PRIMARY_STRING_LITERAL, .string_literal = next);

  if (match(LEFT_PAREN)) {
    AstNode* expr = Parser_expression(parser);
    consume(RIGHT_PAREN);
    return expr;
  }

  return NULL;
}
static AstNode* constant(Parser* parser) {  // @TODO
  /*
   * I_CONSTANT
   * F_CONSTANT
   * ENUMERATION_CONSTANT
   */

  return NULL;
}
static AstNode* enumeration_constant(Parser* parser) {  // @TODO
  /*
   * IDENTIFIER
   */

  return NULL;
}
static AstNode* string(Parser* parser) {  // @TODO
  /*
   * STRING_LITERAL
   * FUNC_NAME
   */

  return NULL;
}
static AstNode* generic_selection(Parser* parser) {  // @TODO
  /*
   * GENERIC '(' assignment_expression ',' generic_assoc_list ')'
   */

  return NULL;
}
static AstNode* generic_assoc_list(Parser* parser) {  // @TODO
  /*
   * generic_association
   * generic_assoc_list ',' generic_association
   */

  return NULL;
}
static AstNode* generic_association(Parser* parser) {  // @TODO
  /*
   * type_name ':' assignment_expression
   * DEFAULT ':' assignment_expression
   */

  return NULL;
}
static AstNode* postfix_expression(Parser* parser) {
  /*
   * primary_expression
   * postfix_expression '[' expression ']'
   * postfix_expression '(' ')'                           @TODO
   * postfix_expression '(' argument_expression_list ')'  @TODO
   * postfix_expression '.' IDENTIFIER
   * postfix_expression PTR_OP IDENTIFIER
   * postfix_expression INC_OP
   * postfix_expression DEC_OP
   * '(' type_name ')' '{' initializer_list '}'           @TODO
   * '(' type_name ')' '{' initializer_list ',' '}'       @TODO
   */
  AstNode* expr = primary_expression(parser);
  Token* token;

  while (true) {
    if (match(LEFT_SQUARE)) {
      AstNode* index = Parser_expression(parser);
      consume(RIGHT_SQUARE);
      expr = AST_POSTFIX(.type = POSTFIX_ARRAY_INDEX, .left = expr,
                         .index_expression = index);
    } else if ((token = match(INC_OP))) {
      // INC_OP is desugaured into: a++ -> a=a+1
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      AstNode* constant_node =
          AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

      return desugar_assign(parser, expr, PLUS, constant_node);
    } else if ((token = match(DEC_OP))) {
      // DEC_OP is desugaured into: a++ -> a=a-1
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      AstNode* constant_node =
          AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

      return desugar_assign(parser, expr, MINUS, constant_node);
    } else
      break;
  }
  return expr;
}
static AstNode* argument_expression_list(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * argument_expression_list ',' assignment_expression
   */

  return NULL;
}
static AstNode* unary_expression(Parser* parser) {  // @DONE
  /*
   * postfix_expression
   * INC_OP unary_expression
   * DEC_OP unary_expression
   * unary_operator cast_expression
   * SIZEOF unary_expression
   * SIZEOF '(' type_name ')'   @TODO
   * ALIGNOF '(' type_name ')'  @TODO
   */
  Token* token;
  
  if ((token = match(AMPERSAND, STAR, PLUS, MINUS, TILDE, BANG, SIZEOF)))
    return AST_UNARY(.op = token, .right = unary_expression(parser));

  else if (match(INC_OP)) {
    Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
    AstNode* constant_node =
        AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

    AstNode* expr = unary_expression(parser);

    return desugar_assign(parser, expr, PLUS, constant_node);
  } else if (match(DEC_OP)) {
    Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
    AstNode* constant_node =
        AST_PRIMARY(.type = PRIMARY_CONSTANT, .constant = constant_token);

    AstNode* expr = unary_expression(parser);

    return desugar_assign(parser, expr, MINUS, constant_node);
  }
  return postfix_expression(parser);
}

static AstNode* cast_expression(Parser* parser) {  // @TODO
  /*
   * unary_expression
   * '(' type_name ')' cast_expression
   */
  return unary_expression(parser);
}
static AstNode* multiplicative_expression(Parser* parser) {  // @DONE
  /*
   * cast_expression
   * multiplicative_expression '*' cast_expression
   * multiplicative_expression '/' cast_expression
   * multiplicative_expression '%' cast_expression
   */
  AstNode* expr = cast_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator = match(STAR, SLASH, PERCENT)))
      break;

    AstNode* right = cast_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* additive_expression(Parser* parser) {  // @DONE
  /*
   * multiplicative_expression
   * additive_expression '+' multiplicative_expression
   * additive_expression '-' multiplicative_expression
   */
  AstNode* expr = multiplicative_expression(parser);
  Token* operator;

  while (true) {
    if (NULL == (operator = match(PLUS, MINUS)))
      break;

    AstNode* right = multiplicative_expression(parser);
    expr = AST_BINARY(.left = expr, .op = operator, .right = right);
  }
  return expr;
}
static AstNode* shift_expression(Parser* parser) {  // @DONE
  /*
   * additive_expression
   * shift_expression LEFT_OP additive_expression
   * shift_expression RIGHT_OP additive_expression
   */
  AstNode * expr = additive_expression(parser);
  Token * operator;

  while (true) {
    if (NULL == (operator = match(LEFT_OP, RIGHT_OP)))
      break;

    AstNode * right = additive_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* relational_expression(Parser* parser) {  // @DONE
  /*
   * shift_expression
   * relational_expression '<' shift_expression
   * relational_expression '>' shift_expression
   * relational_expression LE_OP shift_expression
   * relational_expression GE_OP shift_expression
   */
  AstNode * expr = shift_expression(parser);
  Token * operator;

  while (true) {
    if (NULL == (operator = match(LESS_THAN, GREATER_THAN, LE_OP, GE_OP))) 
      break;

    AstNode * right = shift_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* equality_expression(Parser* parser) {  // @DONE
  /*
   * relational_expression
   * equality_expression EQ_OP relational_expression
   * equality_expression NE_OP relational_expression
   */
  AstNode * expr = relational_expression(parser);
  Token * operator;
  
  while (true) {
    if (NULL == (operator = match(EQ_OP, NE_OP)))
      break;

    AstNode * right = relational_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;

  return relational_expression(parser);
}
static AstNode* and_expression(Parser* parser) {  // @DONE
  /*
   * equality_expression
   * and_expression '&' equality_expression
   */
  AstNode * expr = equality_expression(parser);
  Token * operator;

  while (true) {
    if (NULL == (operator = match(AMPERSAND)))
      break;
    
    AstNode * right = equality_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* exclusive_or_expression(Parser* parser) {  // @DONE
  /*
   * and_expression
   * exclusive_or_expression '^' and_expression
   */
  AstNode * expr = and_expression(parser);
  Token * operator;

  while (true) {
    if(NULL == (operator = match(CARET))) 
      break;

    AstNode * right = and_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* inclusive_or_expression(Parser* parser) {  // @DONE
  /*
   * exclusive_or_expression
   * inclusive_or_expression '|' exclusive_or_expression
   */
  AstNode * expr = exclusive_or_expression(parser);
  Token * operator;

  while (true) {
    if(NULL == (operator = match(BAR)))
      break;

    AstNode * right = and_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* logical_and_expression(Parser* parser) {  // @TODO
  /*
   * inclusive_or_expression
   * logical_and_expression AND_OP inclusive_or_expression
   */
  AstNode * expr = inclusive_or_expression(parser);
  Token * operator;
  
  while (true) {
    if(NULL == (operator = match(AND_OP)))
      break;
  
    AstNode * right = inclusive_or_expression(parser);
    expr = AST_BINARY(.left=expr, .op=operator, .right=right);
  }
  return expr;
}
static AstNode* logical_or_expression(Parser* parser) {  // @TODO
  /*
   * logical_and_expression
   * logical_or_expression OR_OP logical_and_expression
   */

  return logical_and_expression(parser);
}
static AstNode* conditional_expression(Parser* parser) {  // @TODO
  /*
   * logical_or_expression
   * logical_or_expression '?' expression ':' conditional_expression
   */

  return logical_or_expression(parser);
}
static AstNode* assignment_expression(Parser* parser) {  // @TODO
  /*
   * conditional_expression
   * unary_expression assignment_operator assignment_expression
   */

  // The FIRST sets for the grammar rules 'conditional_expression' and
  // 'unary_expression' are not disjoint. To sidestep this,
  // 'assignment_expression is parsed as: : conditional_expression |
  // conditional_expression assignment_operator conditional_expression.
  //
  // Later we'll come back to make sure the lvalue is valid.
  return conditional_expression(parser);
}
static AstNode* assignment_operator(Parser* parser) {  // @TODO
  /*
   * '='
   * MUL_ASSIGN
   * DIV_ASSIGN
   * MOD_ASSIGN
   * ADD_ASSIGN
   * SUB_ASSIGN
   * LEFT_ASSIGN
   * RIGHT_ASSIGN
   * AND_ASSIGN
   * XOR_ASSIGN
   * OR_ASSIGN
   */

  return NULL;
}
AstNode* Parser_expression(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * expression ',' assignment_expression
   */
  return assignment_expression(parser);
}
static AstNode* constant_expression(Parser* parser) {  // @TODO
  /*
   * conditional_expression
   */

  return NULL;
}
