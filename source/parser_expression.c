/* Recursive Descent Parser implementation (expression)
 *
 * The recursive descent parser is implemented as a set of mutually recursive
 * functions for each rule in the grammar. This file provides functions for
 * rules in the 'expression' set.
 *
 * Generated by generate_recursive_parser.py on 2020-03-24.
 */

#include <stddef.h>

#include "ast.h"
#include "parser.h"

AstNode* Parser_primary_expression(Parser* parser) {  // @DONE
  /*
   * IDENTIFIER
   * constant
   * string
   * '(' expression ')'
   * generic_selection  @TODO
   */
  Token* next;

  if ((next = Parser_match_token(parser, IDENTIFIER)))
    return AST_CREATE_PRIMARY(.type = PRIMARY_IDENTIFIER, .identifier = next);

  if ((next = Parser_match_token(parser, CONSTANT)))
    return AST_CREATE_PRIMARY(.type = PRIMARY_CONSTANT, .constant = next);

  if ((next = Parser_match_token(parser, STRING_LITERAL)))
    return AST_CREATE_PRIMARY(.type = PRIMARY_STRING_LITERAL,
                              .string_literal = next);
  if (Parser_match_token(parser, LEFT_PAREN)) {
    AstNode* expr = Parser_expression(parser);
    Parser_consume_token(parser, RIGHT_PAREN);
    return expr;
  }

  return NULL;
}
AstNode* Parser_constant(Parser* parser) {  // @TODO
  /*
   * I_CONSTANT
   * F_CONSTANT
   * ENUMERATION_CONSTANT
   */

  return NULL;
}
AstNode* Parser_enumeration_constant(Parser* parser) {  // @TODO
  /*
   * IDENTIFIER
   */

  return NULL;
}
AstNode* Parser_string(Parser* parser) {  // @TODO
  /*
   * STRING_LITERAL
   * FUNC_NAME
   */

  return NULL;
}
AstNode* Parser_generic_selection(Parser* parser) {  // @TODO
  /*
   * GENERIC '(' assignment_expression ',' generic_assoc_list ')'
   */

  return NULL;
}
AstNode* Parser_generic_assoc_list(Parser* parser) {  // @TODO
  /*
   * generic_association
   * generic_assoc_list ',' generic_association
   */

  return NULL;
}
AstNode* Parser_generic_association(Parser* parser) {  // @TODO
  /*
   * type_name ':' assignment_expression
   * DEFAULT ':' assignment_expression
   */

  return NULL;
}
AstNode* Parser_postfix_expression(Parser* parser) {  // @TODO
  /*
   * primary_expression
   * postfix_expression '[' expression ']'
   * postfix_expression '(' ')'                      
   * postfix_expression '(' argument_expression_list ')' 
   * postfix_expression '.' IDENTIFIER
   * postfix_expression PTR_OP IDENTIFIER
   * postfix_expression INC_OP
   * postfix_expression DEC_OP
   * '(' type_name ')' '{' initializer_list '}'
   * '(' type_name ')' '{' initializer_list ',' '}'
   */
  AstNode* expr = Parser_primary_expression(parser);
  Token* token;

  while (true) {
    if (Parser_match_token(parser, LEFT_SQUARE)) {
      AstNode* index = Parser_expression(parser);
      Parser_consume_token(parser, RIGHT_SQUARE);
      expr = AST_CREATE_POSTFIX(.type = POSTFIX_ARRAY_INDEX, .left = expr,
                                .index_expression = index);
    } else if ((token = Parser_match_token(parser, INC_OP))) {
      // INC_OP is desugaured into: a++ -> a=a+1
      // Create missing tokens for =, a, +, 1.
      Token* equal_token = Parser_create_fake_token(parser, EQUAL, "=");
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      Token* op_token = Parser_create_fake_token(parser, PLUS, "+");

      AstNode* constant_node = AST_CREATE_PRIMARY(.type = PRIMARY_CONSTANT,
                                                  .constant = constant_token);
      AstNode* inc_expr = AST_CREATE_BINARY(.left = expr, .op = op_token,
                                            .right = constant_node);
      expr =
          AST_CREATE_BINARY(.left = expr, .op = equal_token, .right = inc_expr);
    } else if ((token = Parser_match_token(parser, DEC_OP))) {
      // DEC_OP is desugaured into: a++ -> a=a-1
      // Create missing tokens for =, a, -, 1.
      Token* equal_token = Parser_create_fake_token(parser, EQUAL, "=");
      Token* constant_token = Parser_create_fake_token(parser, CONSTANT, "1");
      Token* op_token = Parser_create_fake_token(parser, PLUS, "-");

      AstNode* constant_node = AST_CREATE_PRIMARY(.type = PRIMARY_CONSTANT,
                                                  .constant = constant_token);
      AstNode* inc_expr = AST_CREATE_BINARY(.left = expr, .op = op_token,
                                            .right = constant_node);
      expr =
          AST_CREATE_BINARY(.left = expr, .op = equal_token, .right = inc_expr);
    } else
      break;
  }
  return expr;
}
AstNode* Parser_argument_expression_list(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * argument_expression_list ',' assignment_expression
   */

  return NULL;
}
AstNode* Parser_unary_expression(Parser* parser) {  // @TODO
  /*
   * postfix_expression
   * INC_OP unary_expression
   * DEC_OP unary_expression
   * unary_operator cast_expression
   * SIZEOF unary_expression
   * SIZEOF '(' type_name ')'
   * ALIGNOF '(' type_name ')'
   */

  return Parser_postfix_expression(parser);
}
AstNode* Parser_unary_operator(Parser* parser) {  // @TODO
  /*
   * '&'
   * '*'
   * '+'
   * '-'
   * '~'
   * '!'
   */

  return NULL;
}
AstNode* Parser_cast_expression(Parser* parser) {  // @TODO
  /*
   * unary_expression
   * '(' type_name ')' cast_expression
   */

  return NULL;
}
AstNode* Parser_multiplicative_expression(Parser* parser) {  // @TODO
  /*
   * cast_expression
   * multiplicative_expression '*' cast_expression
   * multiplicative_expression '/' cast_expression
   * multiplicative_expression '%' cast_expression
   */

  return NULL;
}
AstNode* Parser_additive_expression(Parser* parser) {  // @TODO
  /*
   * multiplicative_expression
   * additive_expression '+' multiplicative_expression
   * additive_expression '-' multiplicative_expression
   */

  return NULL;
}
AstNode* Parser_shift_expression(Parser* parser) {  // @TODO
  /*
   * additive_expression
   * shift_expression LEFT_OP additive_expression
   * shift_expression RIGHT_OP additive_expression
   */

  return NULL;
}
AstNode* Parser_relational_expression(Parser* parser) {  // @TODO
  /*
   * shift_expression
   * relational_expression '<' shift_expression
   * relational_expression '>' shift_expression
   * relational_expression LE_OP shift_expression
   * relational_expression GE_OP shift_expression
   */

  return NULL;
}
AstNode* Parser_equality_expression(Parser* parser) {  // @TODO
  /*
   * relational_expression
   * equality_expression EQ_OP relational_expression
   * equality_expression NE_OP relational_expression
   */

  return NULL;
}
AstNode* Parser_and_expression(Parser* parser) {  // @TODO
  /*
   * equality_expression
   * and_expression '&' equality_expression
   */

  return NULL;
}
AstNode* Parser_exclusive_or_expression(Parser* parser) {  // @TODO
  /*
   * and_expression
   * exclusive_or_expression '^' and_expression
   */

  return NULL;
}
AstNode* Parser_inclusive_or_expression(Parser* parser) {  // @TODO
  /*
   * exclusive_or_expression
   * inclusive_or_expression '|' exclusive_or_expression
   */

  return NULL;
}
AstNode* Parser_logical_and_expression(Parser* parser) {  // @TODO
  /*
   * inclusive_or_expression
   * logical_and_expression AND_OP inclusive_or_expression
   */

  return NULL;
}
AstNode* Parser_logical_or_expression(Parser* parser) {  // @TODO
  /*
   * logical_and_expression
   * logical_or_expression OR_OP logical_and_expression
   */

  return NULL;
}
AstNode* Parser_conditional_expression(Parser* parser) {  // @TODO
  /*
   * logical_or_expression
   * logical_or_expression '?' expression ':' conditional_expression
   */

  return NULL;
}
AstNode* Parser_assignment_expression(Parser* parser) {  // @TODO
  /*
   * conditional_expression
   * unary_expression assignment_operator assignment_expression
   */

  return Parser_unary_expression(parser);
}
AstNode* Parser_assignment_operator(Parser* parser) {  // @TODO
  /*
   * '='
   * MUL_ASSIGN
   * DIV_ASSIGN
   * MOD_ASSIGN
   * ADD_ASSIGN
   * SUB_ASSIGN
   * LEFT_ASSIGN
   * RIGHT_ASSIGN
   * AND_ASSIGN
   * XOR_ASSIGN
   * OR_ASSIGN
   */

  return NULL;
}
AstNode* Parser_expression(Parser* parser) {  // @TODO
  /*
   * assignment_expression
   * expression ',' assignment_expression
   */
  return Parser_assignment_expression(parser);
}
AstNode* Parser_constant_expression(Parser* parser) {  // @TODO
  /*
   * conditional_expression
   */

  return NULL;
}
