/* Recursive Descent Parser implementation (declaration)
 *
 * The recursive descent parser is implemented as a set of mutually recursive
 * functions for each rule in the grammar. This file provides functions for
 * rules in the 'declaration' set.
 *
 * Generated by generate_recursive_parser.py on 2020-03-24.
 */

#include <stddef.h>

#include "ast.h"
#include "parser.h"

#define match(...) Parser_match_token(parser, (TokenType[]){__VA_ARGS__, NAT})
#define consume(t) Parser_consume_token(parser, t)
#define peek() Parser_peek_token(parser)

#define static

static CType* declaration_specifiers(Parser* parser);                   // @TODO
static DeclAstNode* init_declarator_list(Parser* parser, CType* type);  // @TODO
static DeclAstNode* init_declarator(Parser* parser, CType* type);       // @TODO
static DeclAstNode* storage_class_specifier(Parser* parser);            // @TODO
static DeclAstNode* type_specifier(Parser* parser);                     // @TODO
static DeclAstNode* struct_or_union_specifier(Parser* parser);          // @TODO
static DeclAstNode* struct_or_union(Parser* parser);                    // @TODO
static DeclAstNode* struct_declaration_list(Parser* parser);            // @TODO
static DeclAstNode* struct_declaration(Parser* parser);                 // @TODO
static DeclAstNode* specifier_qualifier_list(Parser* parser);           // @TODO
static DeclAstNode* struct_declarator_list(Parser* parser);             // @TODO
static DeclAstNode* struct_declarator(Parser* parser);                  // @TODO
static DeclAstNode* enum_specifier(Parser* parser);                     // @TODO
static DeclAstNode* enumerator_list(Parser* parser);                    // @TODO
static DeclAstNode* enumerator(Parser* parser);                         // @TODO
static DeclAstNode* atomic_type_specifier(Parser* parser);              // @TODO
static DeclAstNode* type_qualifier(Parser* parser);                     // @TODO
static DeclAstNode* function_specifier(Parser* parser);                 // @TODO
static DeclAstNode* alignment_specifier(Parser* parser);                // @TODO
static DeclAstNode* declarator(Parser* parser);                         // @TODO
static DeclAstNode* direct_declarator(Parser* parser);                  // @TODO
static DeclAstNode* pointer(Parser* parser);                            // @TODO
static DeclAstNode* type_qualifier_list(Parser* parser);                // @TODO
static DeclAstNode* parameter_type_list(Parser* parser);                // @TODO
static DeclAstNode* parameter_list(Parser* parser);                     // @TODO
static DeclAstNode* parameter_declaration(Parser* parser);              // @TODO
static DeclAstNode* identifier_list(Parser* parser);                    // @TODO
static DeclAstNode* type_name(Parser* parser);                          // @TODO
static DeclAstNode* abstract_declarator(Parser* parser);                // @TODO
static DeclAstNode* direct_abstract_declarator(Parser* parser);         // @TODO
static DeclAstNode* initializer(Parser* parser);                        // @TODO
static DeclAstNode* initializer_list(Parser* parser);                   // @TODO
static DeclAstNode* designation(Parser* parser);                        // @TODO
static DeclAstNode* designator_list(Parser* parser);                    // @TODO
static DeclAstNode* designator(Parser* parser);                         // @TODO
static DeclAstNode* static_assert_declaration(Parser* parser);          // @TODO
static DeclAstNode* translation_unit(Parser* parser);                   // @TODO
static DeclAstNode* external_declaration(Parser* parser);               // @TODO
static DeclAstNode* function_definition(Parser* parser);                // @TODO
static DeclAstNode* declaration_list(Parser* parser);                   // @TODO

DeclAstNode* Parser_declaration(Parser* parser) {  // @TODO
  /*
   * declaration_specifiers ';'
   * declaration_specifiers init_declarator_list ';'
   */
  CType* type = declaration_specifiers(parser);

  if (!match(SEMICOLON)) return DECL(.type = type);

  return init_declarator_list(parser, type);
}
static CType* declaration_specifiers(Parser* parser) {  // @TODO
  /*
   * storage_class_specifier declaration_specifiers
   * storage_class_specifier
   * type_specifier declaration_specifiers
   * type_specifier
   * type_qualifier declaration_specifiers
   * type_qualifier
   * function_specifier declaration_specifiers
   * function_specifier
   * alignment_specifier declaration_specifiers
   * alignment_specifier
   */

  return NULL;
}
static DeclAstNode* init_declarator_list(Parser* parser,
                                         CType* type) {  // @TODO
  /*
   * init_declarator
   * init_declarator_list ',' init_declarator
   */
  DeclAstNode* node = init_declarator(parser, type);

  while (match(COMMA)) {
    DeclAstNode* decl_node = init_declarator(parser, type);
    decl_node->next = node;
    node = decl_node;
  }
  return node;
}
static DeclAstNode* init_declarator(Parser* parser, CType* type) {  // @TODO
  /*
   * declarator '=' initializer
   * declarator
   */
  // For now, the 'declarator' must be an identifier.
  Token* identifier;
  if ((identifier = match(IDENTIFIER))) {
    return DECL(.type = type, .identifier = identifier);
  }
  return NULL;
}
static DeclAstNode* storage_class_specifier(Parser* parser) {  // @TODO
  /*
   * TYPEDEF
   * EXTERN
   * STATIC
   * THREAD_LOCAL
   * AUTO
   * REGISTER
   */

  return NULL;
}
static DeclAstNode* type_specifier(Parser* parser) {  // @TODO
  /*
   * VOID
   * CHAR
   * SHORT
   * INT
   * LONG
   * FLOAT
   * DOUBLE
   * SIGNED
   * UNSIGNED
   * BOOL
   * COMPLEX
   * IMAGINARY
   * atomic_type_specifier
   * struct_or_union_specifier
   * enum_specifier
   * TYPEDEF_NAME
   */

  return NULL;
}
static DeclAstNode* struct_or_union_specifier(Parser* parser) {  // @TODO
  /*
   * struct_or_union '{' struct_declaration_list '}'
   * struct_or_union IDENTIFIER '{' struct_declaration_list '}'
   * struct_or_union IDENTIFIER
   */

  return NULL;
}
static DeclAstNode* struct_or_union(Parser* parser) {  // @TODO
  /*
   * STRUCT
   * UNION
   */

  return NULL;
}
static DeclAstNode* struct_declaration_list(Parser* parser) {  // @TODO
  /*
   * struct_declaration
   * struct_declaration_list struct_declaration
   */

  return NULL;
}
static DeclAstNode* struct_declaration(Parser* parser) {  // @TODO
  /*
   * specifier_qualifier_list '
   */

  return NULL;
}
static DeclAstNode* specifier_qualifier_list(Parser* parser) {  // @TODO
  /*
   * type_specifier specifier_qualifier_list
   * type_specifier
   * type_qualifier specifier_qualifier_list
   * type_qualifier
   */

  return NULL;
}
static DeclAstNode* struct_declarator_list(Parser* parser) {  // @TODO
  /*
   * struct_declarator
   * struct_declarator_list ',' struct_declarator
   */

  return NULL;
}
static DeclAstNode* struct_declarator(Parser* parser) {  // @TODO
  /*
   * ':' constant_expression
   * declarator ':' constant_expression
   * declarator
   */

  return NULL;
}
static DeclAstNode* enum_specifier(Parser* parser) {  // @TODO
  /*
   * ENUM '{' enumerator_list '}'
   * ENUM '{' enumerator_list ',' '}'
   * ENUM IDENTIFIER '{' enumerator_list '}'
   * ENUM IDENTIFIER '{' enumerator_list ',' '}'
   * ENUM IDENTIFIER
   */

  return NULL;
}
static DeclAstNode* enumerator_list(Parser* parser) {  // @TODO
  /*
   * enumerator
   * enumerator_list ',' enumerator
   */

  return NULL;
}
static DeclAstNode* enumerator(Parser* parser) {  // @TODO
  /*
   * enumeration_constant '=' constant_expression
   * enumeration_constant
   */

  return NULL;
}
static DeclAstNode* atomic_type_specifier(Parser* parser) {  // @TODO
  /*
   * ATOMIC '(' type_name ')'
   */

  return NULL;
}
static DeclAstNode* type_qualifier(Parser* parser) {  // @TODO
  /*
   * CONST
   * RESTRICT
   * VOLATILE
   * ATOMIC
   */

  return NULL;
}
static DeclAstNode* function_specifier(Parser* parser) {  // @TODO
  /*
   * INLINE
   * NORETURN
   */

  return NULL;
}
static DeclAstNode* alignment_specifier(Parser* parser) {  // @TODO
  /*
   * ALIGNAS '(' type_name ')'
   * ALIGNAS '(' constant_expression ')'
   */

  return NULL;
}
static DeclAstNode* declarator(Parser* parser) {  // @TODO
  /*
   * pointer direct_declarator
   * direct_declarator
   */

  return NULL;
}
static DeclAstNode* direct_declarator(Parser* parser) {  // @TODO
  /*
   * IDENTIFIER
   * '(' declarator ')'
   * direct_declarator '[' ']'
   * direct_declarator '[' '*' ']'
   * direct_declarator '[' STATIC type_qualifier_list assignment_expression ']'
   * direct_declarator '[' STATIC assignment_expression ']'
   * direct_declarator '[' type_qualifier_list '*' ']'
   * direct_declarator '[' type_qualifier_list STATIC assignment_expression ']'
   * direct_declarator '[' type_qualifier_list assignment_expression ']'
   * direct_declarator '[' type_qualifier_list ']'
   * direct_declarator '[' assignment_expression ']'
   * direct_declarator '(' parameter_type_list ')'
   * direct_declarator '(' ')'
   * direct_declarator '(' identifier_list ')'
   */

  return NULL;
}
static DeclAstNode* pointer(Parser* parser) {  // @TODO
  /*
   * '*' type_qualifier_list pointer
   * '*' type_qualifier_list
   * '*' pointer
   * '*'
   */

  return NULL;
}
static DeclAstNode* type_qualifier_list(Parser* parser) {  // @TODO
  /*
   * type_qualifier
   * type_qualifier_list type_qualifier
   */

  return NULL;
}
static DeclAstNode* parameter_type_list(Parser* parser) {  // @TODO
  /*
   * parameter_list ',' ELLIPSIS
   * parameter_list
   */

  return NULL;
}
static DeclAstNode* parameter_list(Parser* parser) {  // @TODO
  /*
   * parameter_declaration
   * parameter_list ',' parameter_declaration
   */

  return NULL;
}
static DeclAstNode* parameter_declaration(Parser* parser) {  // @TODO
  /*
   * declaration_specifiers declarator
   * declaration_specifiers abstract_declarator
   * declaration_specifiers
   */

  return NULL;
}
static DeclAstNode* identifier_list(Parser* parser) {  // @TODO
  /*
   * IDENTIFIER
   * identifier_list ',' IDENTIFIER
   */

  return NULL;
}
static DeclAstNode* type_name(Parser* parser) {  // @TODO
  /*
   * specifier_qualifier_list abstract_declarator
   * specifier_qualifier_list
   */

  return NULL;
}
static DeclAstNode* abstract_declarator(Parser* parser) {  // @TODO
  /*
   * pointer direct_abstract_declarator
   * pointer
   * direct_abstract_declarator
   */

  return NULL;
}
static DeclAstNode* direct_abstract_declarator(Parser* parser) {  // @TODO
  /*
   * '(' abstract_declarator ')'
   * '[' ']'
   * '[' constant_expression ']'
   * direct_abstract_declarator '[' ']'
   * direct_abstract_declarator '[' constant_expression ']'
   * '(' ')'
   * '(' parameter_type_list ')'
   * direct_abstract_declarator '(' ')'
   * direct_abstract_declarator '(' parameter_type_list ')'
   */

  return NULL;
}
static DeclAstNode* initializer(Parser* parser) {  // @TODO
  /*
   * '{' initializer_list '}'
   * '{' initializer_list ',' '}'
   * assignment_expression
   */

  return NULL;
}
static DeclAstNode* initializer_list(Parser* parser) {  // @TODO
  /*
   * designation initializer
   * initializer
   * initializer_list ',' designation initializer
   * initializer_list ',' initializer
   */

  return NULL;
}
static DeclAstNode* designation(Parser* parser) {  // @TODO
  /*
   * designator_list '='
   */

  return NULL;
}
static DeclAstNode* designator_list(Parser* parser) {  // @TODO
  /*
   * designator
   * designator_list designator
   */

  return NULL;
}
static DeclAstNode* designator(Parser* parser) {  // @TODO
  /*
   * '[' constant_expression ']'
   * '.' IDENTIFIER
   */

  return NULL;
}
static DeclAstNode* static_assert_declaration(Parser* parser) {  // @TODO
  /*
   * STATIC_ASSERT '(' constant_expression ',' STRING_LITERAL ')' '
   */

  return NULL;
}
static DeclAstNode* translation_unit(Parser* parser) {  // @TODO
  /*
   * external_declaration
   * translation_unit external_declaration
   */

  return NULL;
}
static DeclAstNode* external_declaration(Parser* parser) {  // @TODO
  /*
   * function_definition
   * declaration
   */

  return NULL;
}
static DeclAstNode* function_definition(Parser* parser) {  // @TODO
  /*
   * declaration_specifiers declarator declaration_list compound_statement
   * declaration_specifiers declarator compound_statement
   */

  return NULL;
}
static DeclAstNode* declaration_list(Parser* parser) {  // @TODO
  /*
   * declaration
   * declaration_list declaration
   */

  return NULL;
}
